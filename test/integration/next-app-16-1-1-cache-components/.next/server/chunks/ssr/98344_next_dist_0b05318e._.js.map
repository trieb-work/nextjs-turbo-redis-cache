{"version":3,"sources":["../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/manifests-singleton.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/encryption-utils.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/encryption.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/lib/format-server-error.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/redirect-status-code.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/redirect-error.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/client/components/is-next-router-error.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/shared/lib/is-plain-object.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/lib/is-error.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/lib/error-telemetry-utils.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/react-large-shell-error.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/app-render/create-error-handler.tsx","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/use-cache/constants.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/lib/lru-cache.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/lib/cache-handlers/default.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/use-cache/handlers.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/use-cache/use-cache-errors.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/web/spec-extension/adapters/reflect.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/shared/lib/utils/reflect-utils.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/request/utils.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/request/search-params.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/lib/lazy-result.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/lib/picocolors.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/build/output/log.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/server/use-cache/use-cache-wrapper.ts","../../../../node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.5_react-dom%4019.2.0_react%4019.2.0__react%4019.2.0/node_modules/next/src/build/webpack/loaders/next-flight-loader/cache-wrapper.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nexport interface ServerModuleMap {\n  readonly [name: string]: {\n    readonly id: string | number\n    readonly name: string\n    readonly chunks: Readonly<Array<string>> // currently not used\n    readonly async?: boolean\n  }\n}\n\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests')\n\ninterface ManifestsSingleton {\n  readonly clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n  readonly proxiedClientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: ServerModuleMap\n}\n\ntype GlobalThisWithManifests = typeof globalThis & {\n  [MANIFESTS_SINGLETON]?: ManifestsSingleton\n}\n\ntype ClientReferenceManifestMappingProp =\n  | 'clientModules'\n  | 'rscModuleMapping'\n  | 'edgeRscModuleMapping'\n  | 'ssrModuleMapping'\n  | 'edgeSSRModuleMapping'\n\nconst globalThisWithManifests = globalThis as GlobalThisWithManifests\n\nfunction createProxiedClientReferenceManifest(\n  clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n): DeepReadonly<ClientReferenceManifest> {\n  const createMappingProxy = (prop: ClientReferenceManifestMappingProp) => {\n    return new Proxy(\n      {},\n      {\n        get(_, id: string) {\n          const workStore = workAsyncStorage.getStore()\n\n          if (workStore) {\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (currentManifest?.[prop][id]) {\n              return currentManifest[prop][id]\n            }\n\n            // In development, we also check all other manifests to see if the\n            // module exists there. This is to support a scenario where React's\n            // I/O tracking (dev-only) creates a connection from one page to\n            // another through an emitted async I/O node that references client\n            // components from the other page, e.g. in owner props.\n            // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n            // to avoid this workaround. The current workaround has the\n            // disadvantage that one might accidentally or intentionally share\n            // client references across pages (e.g. by storing them in a global\n            // variable), which would then only be caught in production.\n            if (process.env.NODE_ENV !== 'production') {\n              for (const [\n                route,\n                manifest,\n              ] of clientReferenceManifestsPerRoute) {\n                if (route === workStore.route) {\n                  continue\n                }\n\n                const entry = manifest[prop][id]\n\n                if (entry !== undefined) {\n                  return entry\n                }\n              }\n            }\n          } else {\n            // If there's no work store defined, we can assume that a client\n            // reference manifest is needed during module evaluation, e.g. to\n            // create a server function using a higher-order function. This\n            // might also use client components which need to be serialized by\n            // Flight, and therefore client references need to be resolvable. In\n            // that case we search all page manifests to find the module.\n            for (const manifest of clientReferenceManifestsPerRoute.values()) {\n              const entry = manifest[prop][id]\n\n              if (entry !== undefined) {\n                return entry\n              }\n            }\n          }\n\n          return undefined\n        },\n      }\n    )\n  }\n\n  const mappingProxies = new Map<\n    ClientReferenceManifestMappingProp,\n    ReturnType<typeof createMappingProxy>\n  >()\n\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        const workStore = workAsyncStorage.getStore()\n\n        switch (prop) {\n          case 'moduleLoading':\n          case 'entryCSSFiles':\n          case 'entryJSFiles': {\n            if (!workStore) {\n              throw new InvariantError(\n                `Cannot access \"${prop}\" without a work store.`\n              )\n            }\n\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (!currentManifest) {\n              throw new InvariantError(\n                `The client reference manifest for route \"${workStore.route}\" does not exist.`\n              )\n            }\n\n            return currentManifest[prop]\n          }\n          case 'clientModules':\n          case 'rscModuleMapping':\n          case 'edgeRscModuleMapping':\n          case 'ssrModuleMapping':\n          case 'edgeSSRModuleMapping': {\n            let proxy = mappingProxies.get(prop)\n\n            if (!proxy) {\n              proxy = createMappingProxy(prop)\n              mappingProxies.set(prop, proxy)\n            }\n\n            return proxy\n          }\n          default: {\n            throw new InvariantError(\n              `This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`\n            )\n          }\n        }\n      },\n    }\n  ) as DeepReadonly<ClientReferenceManifest>\n}\n\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */\nfunction createServerModuleMap(): ServerModuleMap {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          getServerActionsManifest()[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string\n): string | undefined {\n  const serverActionsManifest = getServerActionsManifest()\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n\n  // There are no workers to handle this action, nothing to forward to.\n  if (!workers) {\n    return\n  }\n\n  // If there is an entry for the current page, we don't need to forward.\n  if (workers[normalizeWorkerPageName(pageName)]) {\n    return\n  }\n\n  // Otherwise, grab the first worker that has a handler for this action id.\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\nexport function setManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n}) {\n  const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (existingSingleton) {\n    existingSingleton.clientReferenceManifestsPerRoute.set(\n      normalizeAppPath(page),\n      clientReferenceManifest\n    )\n\n    existingSingleton.serverActionsManifest = serverActionsManifest\n  } else {\n    const clientReferenceManifestsPerRoute = new Map<\n      string,\n      DeepReadonly<ClientReferenceManifest>\n    >([[normalizeAppPath(page), clientReferenceManifest]])\n\n    const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(\n      clientReferenceManifestsPerRoute\n    )\n\n    globalThisWithManifests[MANIFESTS_SINGLETON] = {\n      clientReferenceManifestsPerRoute,\n      proxiedClientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap(),\n    }\n  }\n}\n\nfunction getManifestsSingleton(): ManifestsSingleton {\n  const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (!manifestSingleton) {\n    throw new InvariantError('The manifests singleton was not initialized.')\n  }\n\n  return manifestSingleton\n}\n\nexport function getClientReferenceManifest(): DeepReadonly<ClientReferenceManifest> {\n  return getManifestsSingleton().proxiedClientReferenceManifest\n}\n\nexport function getServerActionsManifest(): DeepReadonly<ActionManifest> {\n  return getManifestsSingleton().serverActionsManifest\n}\n\nexport function getServerModuleMap() {\n  return getManifestsSingleton().serverModuleMap\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { getServerActionsManifest } from './manifests-singleton'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifest = getServerActionsManifest()\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifest()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifest()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","const invalidServerComponentReactHooks = [\n  'useDeferredValue',\n  'useEffect',\n  'useImperativeHandle',\n  'useInsertionEffect',\n  'useLayoutEffect',\n  'useReducer',\n  'useRef',\n  'useState',\n  'useSyncExternalStore',\n  'useTransition',\n  'experimental_useOptimistic',\n  'useOptimistic',\n]\n\nfunction setMessage(error: Error, message: string): void {\n  error.message = message\n  if (error.stack) {\n    const lines = error.stack.split('\\n')\n    lines[0] = message\n    error.stack = lines.join('\\n')\n  }\n}\n\n/**\n * Input:\n * Error: Something went wrong\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10)\n \n * Output:\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10) \n */\nexport function getStackWithoutErrorMessage(error: Error): string {\n  const stack = error.stack\n  if (!stack) return ''\n  return stack.replace(/^[^\\n]*\\n/, '')\n}\n\nexport function formatServerError(error: Error): void {\n  if (typeof error?.message !== 'string') return\n\n  if (\n    error.message.includes(\n      'Class extends value undefined is not a constructor or null'\n    )\n  ) {\n    const addedMessage =\n      'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component'\n\n    // If this error instance already has the message, don't add it again\n    if (error.message.includes(addedMessage)) return\n\n    setMessage(\n      error,\n      `${error.message}\n\n${addedMessage}`\n    )\n    return\n  }\n\n  if (error.message.includes('createContext is not a function')) {\n    setMessage(\n      error,\n      'createContext only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component'\n    )\n    return\n  }\n\n  for (const clientHook of invalidServerComponentReactHooks) {\n    const regex = new RegExp(`\\\\b${clientHook}\\\\b.*is not a function`)\n    if (regex.test(error.message)) {\n      setMessage(\n        error,\n        `${clientHook} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`\n      )\n      return\n    }\n  }\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n","import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","export function getObjectClassLabel(value: any): string {\n  return Object.prototype.toString.call(value)\n}\n\nexport function isPlainObject(value: any): boolean {\n  if (getObjectClassLabel(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n\n  /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */\n  return prototype === null || prototype.hasOwnProperty('isPrototypeOf')\n}\n","import { isPlainObject } from '../shared/lib/is-plain-object'\n\n// We allow some additional attached properties for Next.js errors\nexport interface NextError extends Error {\n  type?: string\n  page?: string\n  code?: string | number\n  cancelled?: boolean\n  digest?: number\n}\n\n/**\n * This is a safe stringify function that handles circular references.\n * We're using a simpler version here to avoid introducing\n * the dependency `safe-stable-stringify` into production bundle.\n *\n * This helper is used both in development and production.\n */\nfunction safeStringifyLite(obj: any) {\n  const seen = new WeakSet()\n\n  return JSON.stringify(obj, (_key, value) => {\n    // If value is an object and already seen, replace with \"[Circular]\"\n    if (typeof value === 'object' && value !== null) {\n      if (seen.has(value)) {\n        return '[Circular]'\n      }\n      seen.add(value)\n    }\n    return value\n  })\n}\n\n/**\n * Checks whether the given value is a NextError.\n * This can be used to print a more detailed error message with properties like `code` & `digest`.\n */\nexport default function isError(err: unknown): err is NextError {\n  return (\n    typeof err === 'object' && err !== null && 'name' in err && 'message' in err\n  )\n}\n\nexport function getProperError(err: unknown): Error {\n  if (isError(err)) {\n    return err\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // provide better error for case where `throw undefined`\n    // is called in development\n    if (typeof err === 'undefined') {\n      return new Error(\n        'An undefined error was thrown, ' +\n          'see here for more info: https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n\n    if (err === null) {\n      return new Error(\n        'A null error was thrown, ' +\n          'see here for more info: https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n  }\n\n  return new Error(isPlainObject(err) ? safeStringifyLite(err) : err + '')\n}\n","const ERROR_CODE_DELIMITER = '@'\n\n/**\n * Augments the digest field of errors thrown in React Server Components (RSC) with an error code.\n * Since RSC errors can only be serialized through the digest field, this provides a way to include\n * an additional error code that can be extracted client-side via `extractNextErrorCode`.\n *\n * The error code is appended to the digest string with a semicolon separator, allowing it to be\n * parsed out later while preserving the original digest value.\n */\nexport const createDigestWithErrorCode = (\n  thrownValue: unknown,\n  originalDigest: string\n): string => {\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    '__NEXT_ERROR_CODE' in thrownValue\n  ) {\n    return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`\n  }\n  return originalDigest\n}\n\nexport const extractNextErrorCode = (error: unknown): string | undefined => {\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    '__NEXT_ERROR_CODE' in error &&\n    typeof error.__NEXT_ERROR_CODE === 'string'\n  ) {\n    return error.__NEXT_ERROR_CODE\n  }\n\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    'digest' in error &&\n    typeof error.digest === 'string'\n  ) {\n    const segments = error.digest.split(ERROR_CODE_DELIMITER)\n    const errorCode = segments.find((segment) => segment.startsWith('E'))\n    return errorCode\n  }\n\n  return undefined\n}\n","// TODO: isWellKnownError -> isNextInternalError\n// isReactLargeShellError -> isWarning\nexport function isReactLargeShellError(\n  error: unknown\n): error is Error & { digest?: string } {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof error.message === 'string' &&\n    error.message.startsWith('This rendered a large document (>')\n  )\n}\n","import type { ErrorInfo } from 'react'\nimport stringHash from 'next/dist/compiled/string-hash'\n\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\n\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string; environmentName?: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  // If this is a prerender interrupted error, we don't need to log the error.\n  if (isPrerenderInterruptedError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  onReactServerRenderError: (err: DigestedError, silenceLog: boolean) => void,\n  spanToRecordOn?: any\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let err = getProperError(thrownValue) as DigestedError\n    let silenceLog = false\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (\n        process.env.NODE_ENV === 'production' &&\n        reactServerErrors.has(err.digest)\n      ) {\n        // This error is likely an obfuscated error from another react-server\n        // environment (e.g. 'use cache'). We recover the original error here\n        // for reporting purposes.\n        err = reactServerErrors.get(err.digest)!\n        // We don't log it again though, as it was already logged in the\n        // original environment.\n        silenceLog = true\n      } else {\n        // Either we're in development (where we want to keep the transported\n        // error with environmentName), or the error is not in reactServerErrors\n        // but has a digest from other means. Keep the error as-is.\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n        stringHash(err.message + (err.stack || '')).toString()\n      )\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception on the provided span if available, otherwise try active span.\n      const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setAttribute('error.type', err.name)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      onReactServerRenderError(err, silenceLog)\n    }\n\n    return err.digest\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void,\n  spanToRecordOn?: any\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        stringHash(\n          err.message + (errorInfo?.componentStack || err.stack || '')\n        ).toString()\n      )\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // HTML errors contain RSC errors as well, filter them out before reporting\n      if (isSSRError) {\n        // Record exception on the provided span if available, otherwise try active span.\n        const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n        if (span) {\n          span.recordException(err)\n          span.setAttribute('error.type', err.name)\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message,\n          })\n        }\n\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return err.digest\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n","export const DYNAMIC_EXPIRE = 300 // 5 minutes\nexport const RUNTIME_PREFETCH_DYNAMIC_STALE = 30 // 30 seconds\n","/**\n * Node in the doubly-linked list used for LRU tracking.\n * Each node represents a cache entry with bidirectional pointers.\n */\nclass LRUNode<T> {\n  public readonly key: string\n  public data: T\n  public size: number\n  public prev: LRUNode<T> | SentinelNode<T> | null = null\n  public next: LRUNode<T> | SentinelNode<T> | null = null\n\n  constructor(key: string, data: T, size: number) {\n    this.key = key\n    this.data = data\n    this.size = size\n  }\n}\n\n/**\n * Sentinel node used for head/tail boundaries.\n * These nodes don't contain actual cache data but simplify list operations.\n */\nclass SentinelNode<T> {\n  public prev: LRUNode<T> | SentinelNode<T> | null = null\n  public next: LRUNode<T> | SentinelNode<T> | null = null\n}\n\n/**\n * LRU (Least Recently Used) Cache implementation using a doubly-linked list\n * and hash map for O(1) operations.\n *\n * Algorithm:\n * - Uses a doubly-linked list to maintain access order (most recent at head)\n * - Hash map provides O(1) key-to-node lookup\n * - Sentinel head/tail nodes simplify edge case handling\n * - Size-based eviction supports custom size calculation functions\n *\n * Data Structure Layout:\n * HEAD <-> [most recent] <-> ... <-> [least recent] <-> TAIL\n *\n * Operations:\n * - get(): Move accessed node to head (mark as most recent)\n * - set(): Add new node at head, evict from tail if over capacity\n * - Eviction: Remove least recent node (tail.prev) when size exceeds limit\n */\nexport class LRUCache<T> {\n  private readonly cache: Map<string, LRUNode<T>> = new Map()\n  private readonly head: SentinelNode<T>\n  private readonly tail: SentinelNode<T>\n  private totalSize: number = 0\n  private readonly maxSize: number\n  private readonly calculateSize: ((value: T) => number) | undefined\n\n  constructor(maxSize: number, calculateSize?: (value: T) => number) {\n    this.maxSize = maxSize\n    this.calculateSize = calculateSize\n\n    // Create sentinel nodes to simplify doubly-linked list operations\n    // HEAD <-> TAIL (empty list)\n    this.head = new SentinelNode<T>()\n    this.tail = new SentinelNode<T>()\n    this.head.next = this.tail\n    this.tail.prev = this.head\n  }\n\n  /**\n   * Adds a node immediately after the head (marks as most recently used).\n   * Used when inserting new items or when an item is accessed.\n   * PRECONDITION: node must be disconnected (prev/next should be null)\n   */\n  private addToHead(node: LRUNode<T>): void {\n    node.prev = this.head\n    node.next = this.head.next\n    // head.next is always non-null (points to tail or another node)\n    this.head.next!.prev = node\n    this.head.next = node\n  }\n\n  /**\n   * Removes a node from its current position in the doubly-linked list.\n   * Updates the prev/next pointers of adjacent nodes to maintain list integrity.\n   * PRECONDITION: node must be connected (prev/next are non-null)\n   */\n  private removeNode(node: LRUNode<T>): void {\n    // Connected nodes always have non-null prev/next\n    node.prev!.next = node.next\n    node.next!.prev = node.prev\n  }\n\n  /**\n   * Moves an existing node to the head position (marks as most recently used).\n   * This is the core LRU operation - accessed items become most recent.\n   */\n  private moveToHead(node: LRUNode<T>): void {\n    this.removeNode(node)\n    this.addToHead(node)\n  }\n\n  /**\n   * Removes and returns the least recently used node (the one before tail).\n   * This is called during eviction when the cache exceeds capacity.\n   * PRECONDITION: cache is not empty (ensured by caller)\n   */\n  private removeTail(): LRUNode<T> {\n    const lastNode = this.tail.prev as LRUNode<T>\n    // tail.prev is always non-null and always LRUNode when cache is not empty\n    this.removeNode(lastNode)\n    return lastNode\n  }\n\n  /**\n   * Sets a key-value pair in the cache.\n   * If the key exists, updates the value and moves to head.\n   * If new, adds at head and evicts from tail if necessary.\n   *\n   * Time Complexity:\n   * - O(1) for uniform item sizes\n   * - O(k) where k is the number of items evicted (can be O(N) for variable sizes)\n   */\n  public set(key: string, value: T): void {\n    const size = this.calculateSize?.(value) ?? 1\n    if (size > this.maxSize) {\n      console.warn('Single item size exceeds maxSize')\n      return\n    }\n\n    const existing = this.cache.get(key)\n    if (existing) {\n      // Update existing node: adjust size and move to head (most recent)\n      existing.data = value\n      this.totalSize = this.totalSize - existing.size + size\n      existing.size = size\n      this.moveToHead(existing)\n    } else {\n      // Add new node at head (most recent position)\n      const newNode = new LRUNode(key, value, size)\n      this.cache.set(key, newNode)\n      this.addToHead(newNode)\n      this.totalSize += size\n    }\n\n    // Evict least recently used items until under capacity\n    while (this.totalSize > this.maxSize && this.cache.size > 0) {\n      const tail = this.removeTail()\n      this.cache.delete(tail.key)\n      this.totalSize -= tail.size\n    }\n  }\n\n  /**\n   * Checks if a key exists in the cache.\n   * This is a pure query operation - does NOT update LRU order.\n   *\n   * Time Complexity: O(1)\n   */\n  public has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Retrieves a value by key and marks it as most recently used.\n   * Moving to head maintains the LRU property for future evictions.\n   *\n   * Time Complexity: O(1)\n   */\n  public get(key: string): T | undefined {\n    const node = this.cache.get(key)\n    if (!node) return undefined\n\n    // Mark as most recently used by moving to head\n    this.moveToHead(node)\n\n    return node.data\n  }\n\n  /**\n   * Returns an iterator over the cache entries. The order is outputted in the\n   * order of most recently used to least recently used.\n   */\n  public *[Symbol.iterator](): IterableIterator<[string, T]> {\n    let current = this.head.next\n    while (current && current !== this.tail) {\n      // Between head and tail, current is always LRUNode\n      const node = current as LRUNode<T>\n      yield [node.key, node.data]\n      current = current.next\n    }\n  }\n\n  /**\n   * Removes a specific key from the cache.\n   * Updates both the hash map and doubly-linked list.\n   *\n   * Time Complexity: O(1)\n   */\n  public remove(key: string): void {\n    const node = this.cache.get(key)\n    if (!node) return\n\n    this.removeNode(node)\n    this.cache.delete(key)\n    this.totalSize -= node.size\n  }\n\n  /**\n   * Returns the number of items in the cache.\n   */\n  public get size(): number {\n    return this.cache.size\n  }\n\n  /**\n   * Returns the current total size of all cached items.\n   * This uses the custom size calculation if provided.\n   */\n  public get currentSize(): number {\n    return this.totalSize\n  }\n}\n","/**\n * This is the default \"use cache\" handler it defaults to an in-memory store.\n * In-memory caches are fragile and should not use stale-while-revalidate\n * semantics on the caches because it's not worth warming up an entry that's\n * likely going to get evicted before we get to use it anyway. However, we also\n * don't want to reuse a stale entry for too long so stale entries should be\n * considered expired/missing in such cache handlers.\n */\n\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  areTagsExpired,\n  areTagsStale,\n  tagsManifest,\n  type TagManifestEntry,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\nexport function createDefaultCacheHandler(maxSize: number): CacheHandler {\n  // If the max size is 0, return a cache handler that doesn't cache anything,\n  // this avoids an unnecessary LRUCache instance and potential memory\n  // allocation.\n  if (maxSize === 0) {\n    return {\n      get: () => Promise.resolve(undefined),\n      set: () => Promise.resolve(),\n      refreshTags: () => Promise.resolve(),\n      getExpiration: () => Promise.resolve(0),\n      updateTags: () => Promise.resolve(),\n    }\n  }\n\n  const memoryCache = new LRUCache<PrivateCacheEntry>(\n    maxSize,\n    (entry) => entry.size\n  )\n  const pendingSets = new Map<string, Promise<void>>()\n\n  const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n    ? console.debug.bind(console, 'DefaultCacheHandler:')\n    : undefined\n\n  return {\n    async get(cacheKey) {\n      const pendingPromise = pendingSets.get(cacheKey)\n\n      if (pendingPromise) {\n        debug?.('get', cacheKey, 'pending')\n        await pendingPromise\n      }\n\n      const privateEntry = memoryCache.get(cacheKey)\n\n      if (!privateEntry) {\n        debug?.('get', cacheKey, 'not found')\n        return undefined\n      }\n\n      const entry = privateEntry.entry\n      if (\n        performance.timeOrigin + performance.now() >\n        entry.timestamp + entry.revalidate * 1000\n      ) {\n        // In-memory caches should expire after revalidate time because it is\n        // unlikely that a new entry will be able to be used before it is dropped\n        // from the cache.\n        debug?.('get', cacheKey, 'expired')\n\n        return undefined\n      }\n\n      let revalidate = entry.revalidate\n\n      if (areTagsExpired(entry.tags, entry.timestamp)) {\n        debug?.('get', cacheKey, 'had expired tag')\n        return undefined\n      }\n\n      if (areTagsStale(entry.tags, entry.timestamp)) {\n        debug?.('get', cacheKey, 'had stale tag')\n        revalidate = -1\n      }\n\n      const [returnStream, newSaved] = entry.value.tee()\n      entry.value = newSaved\n\n      debug?.('get', cacheKey, 'found', {\n        tags: entry.tags,\n        timestamp: entry.timestamp,\n        expire: entry.expire,\n        revalidate,\n      })\n\n      return {\n        ...entry,\n        revalidate,\n        value: returnStream,\n      }\n    },\n\n    async set(cacheKey, pendingEntry) {\n      debug?.('set', cacheKey, 'start')\n\n      let resolvePending: () => void = () => {}\n      const pendingPromise = new Promise<void>((resolve) => {\n        resolvePending = resolve\n      })\n      pendingSets.set(cacheKey, pendingPromise)\n\n      const entry = await pendingEntry\n\n      let size = 0\n\n      try {\n        const [value, clonedValue] = entry.value.tee()\n        entry.value = value\n        const reader = clonedValue.getReader()\n\n        for (let chunk; !(chunk = await reader.read()).done; ) {\n          size += Buffer.from(chunk.value).byteLength\n        }\n\n        memoryCache.set(cacheKey, {\n          entry,\n          isErrored: false,\n          errorRetryCount: 0,\n          size,\n        })\n\n        debug?.('set', cacheKey, 'done')\n      } catch (err) {\n        // TODO: store partial buffer with error after we retry 3 times\n        debug?.('set', cacheKey, 'failed', err)\n      } finally {\n        resolvePending()\n        pendingSets.delete(cacheKey)\n      }\n    },\n\n    async refreshTags() {\n      // Nothing to do for an in-memory cache handler.\n    },\n\n    async getExpiration(tags) {\n      const expirations = tags.map((tag) => {\n        const entry = tagsManifest.get(tag)\n        if (!entry) return 0\n        // Return the most recent timestamp (either expired or stale)\n        return entry.expired || 0\n      })\n\n      const expiration = Math.max(...expirations, 0)\n\n      debug?.('getExpiration', { tags, expiration })\n\n      return expiration\n    },\n\n    async updateTags(tags, durations) {\n      const now = Math.round(performance.timeOrigin + performance.now())\n      debug?.('updateTags', { tags, timestamp: now })\n\n      for (const tag of tags) {\n        // TODO: update file-system-cache?\n        const existingEntry = tagsManifest.get(tag) || {}\n\n        if (durations) {\n          // Use provided durations directly\n          const updates: TagManifestEntry = { ...existingEntry }\n\n          // mark as stale immediately\n          updates.stale = now\n\n          if (durations.expire !== undefined) {\n            updates.expired = now + durations.expire * 1000 // Convert seconds to ms\n          }\n\n          tagsManifest.set(tag, updates)\n        } else {\n          // Update expired field for immediate expiration (default behavior when no durations provided)\n          tagsManifest.set(tag, { ...existingEntry, expired: now })\n        }\n      }\n    },\n  }\n}\n","import { createDefaultCacheHandler } from '../lib/cache-handlers/default'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache: ${message}`, ...args)\n    }\n  : undefined\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @param cacheMaxMemorySize - The maximum memory size of the cache in bytes, if\n *  not provided, the default memory size will be used.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(cacheMaxMemorySize: number): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug?.('cache handlers already initialized')\n    return false\n  }\n\n  debug?.('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug?.('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug?.('setting \"default\" cache handler from default')\n      fallback = createDefaultCacheHandler(cacheMaxMemorySize)\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug?.('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug?.('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    const handler = createDefaultCacheHandler(cacheMaxMemorySize)\n\n    debug?.('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', handler)\n    debug?.('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', handler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it does not exist.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get a set iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not\n * initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Get a map iterator over the cache handlers (keyed by kind).\n * @returns An iterator over the cache handler entries, or `undefined` if they\n * are not initialized.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandlerEntries():\n  | MapIterator<[string, CacheHandler]>\n  | undefined {\n  if (!reference[handlersMapSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersMapSymbol].entries()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug?.('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n","const USE_CACHE_TIMEOUT_ERROR_CODE = 'USE_CACHE_TIMEOUT'\n\nexport class UseCacheTimeoutError extends Error {\n  digest: typeof USE_CACHE_TIMEOUT_ERROR_CODE = USE_CACHE_TIMEOUT_ERROR_CODE\n\n  constructor() {\n    super(\n      'Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".'\n    )\n  }\n}\n\nexport function isUseCacheTimeoutError(\n  err: unknown\n): err is UseCacheTimeoutError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === USE_CACHE_TIMEOUT_ERROR_CODE\n}\n","export class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown\n  ): any {\n    const value = Reflect.get(target, prop, receiver)\n    if (typeof value === 'function') {\n      return value.bind(target)\n    }\n\n    return value\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver)\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop)\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol\n  ): boolean {\n    return Reflect.deleteProperty(target, prop)\n  }\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Cache Components is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_CACHE_COMPONENTS\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\n// even if this would have been fine too `searchParams._`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  'status',\n  // 'value',\n  // 'error',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\n\nexport function throwWithStaticGenerationBailoutErrorWithDynamicError(\n  route: string,\n  expression: string\n): never {\n  throw new StaticGenBailoutError(\n    `Route ${route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n  )\n}\n\nexport function throwForSearchParamsAccessInUseCache(\n  workStore: WorkStore,\n  constructorOpt: Function\n): never {\n  const error = new Error(\n    `Route ${workStore.route} used \\`searchParams\\` inside \"use cache\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\`searchParams\\` outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n  )\n\n  Error.captureStackTrace(error, constructorOpt)\n  workStore.invalidDynamicUsageError ??= error\n\n  throw error\n}\n\nexport function isRequestAPICallableInsideAfter() {\n  const afterTaskStore = afterTaskAsyncStorage.getStore()\n  return afterTaskStore?.rootTaskSpawnPhase === 'action'\n}\n","import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  annotateDynamicAccess,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n  type PrerenderStoreModernRuntime,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in cache contexts.'\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerSearchParamsForServerPage should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderSearchParams(\n          underlyingSearchParams,\n          workUnitStore\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        // We're prerendering in a mode that aborts (cacheComponents) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          '`searchParams`'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n        return Promise.resolve({})\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createStaticPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a cacheComponents (PPR or otherwise) prerender\n      return makeHangingSearchParams(workStore, prerenderStore)\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // We are in a legacy static generation and need to interrupt the\n      // prerender when search params are accessed.\n      return makeErroringSearchParams(workStore, prerenderStore)\n    default:\n      return prerenderStore satisfies never\n  }\n}\n\nfunction createRuntimePrerenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<SearchParams> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedSearchParams(underlyingSearchParams)\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      // Semantically we only need the dev tracking when running in `next dev`\n      // but since you would never use next dev with production NODE_ENV we use this\n      // as a proxy so we can statically exclude this code from production builds.\n      return makeUntrackedSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore,\n        requestStore\n      )\n    } else {\n      return makeUntrackedSearchParams(underlyingSearchParams)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeHangingSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (typeof prop === 'string' && prop === 'then') {\n        const expression =\n          '`await searchParams`, `searchParams.then`, or similar'\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no cacheComponents)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (requestStore.asyncApiPromises) {\n    // Do not cache the resulting promise. If we do, we'll only show the first \"awaited at\"\n    // across all segments that receive searchParams.\n    return makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n  } else {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n    if (cachedSearchParams) {\n      return cachedSearchParams\n    }\n    const promise = makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n    CachedSearchParams.set(requestStore, promise)\n    return promise\n  }\n}\n\nfunction makeUntrackedSearchParamsWithDevWarningsImpl(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  const promiseInitialized = { current: false }\n  const proxiedUnderlying = instrumentSearchParamsObjectWithDevWarnings(\n    underlyingSearchParams,\n    workStore,\n    promiseInitialized\n  )\n\n  let promise: Promise<SearchParams>\n  if (requestStore.asyncApiPromises) {\n    // We wrap each instance of searchParams in a `new Promise()`.\n    // This is important when all awaits are in third party which would otherwise\n    // track all the way to the internal params.\n    const sharedSearchParamsParent =\n      requestStore.asyncApiPromises.sharedSearchParamsParent\n    promise = new Promise((resolve, reject) => {\n      sharedSearchParamsParent.then(() => resolve(proxiedUnderlying), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'searchParams'\n  } else {\n    promise = makeDevtoolsIOAwarePromise(\n      proxiedUnderlying,\n      requestStore,\n      RenderStage.Runtime\n    )\n  }\n  promise.then(\n    () => {\n      promiseInitialized.current = true\n    },\n    // If we're in staged rendering, this promise will reject if the render\n    // is aborted before it can reach the runtime stage.\n    // In that case, we have to prevent an unhandled rejection from the promise\n    // created by this `.then()` call.\n    // This does not affect the `promiseInitialized` logic above,\n    // because `proxiedUnderlying` will not be used to resolve the promise,\n    // so there's no risk of any of its properties being accessed and triggering\n    // an undesireable warning.\n    ignoreReject\n  )\n\n  return instrumentSearchParamsPromiseWithDevWarnings(\n    underlyingSearchParams,\n    promise,\n    workStore\n  )\n}\n\nfunction ignoreReject() {}\n\nfunction instrumentSearchParamsObjectWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  promiseInitialized: { current: boolean }\n) {\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  return new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized.current) {\n        if (workStore.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (workStore.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (workStore.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nfunction instrumentSearchParamsPromiseWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  promise: Promise<SearchParams>,\n  workStore: WorkStore\n) {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && workStore.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","export type LazyResult<TValue> = PromiseLike<TValue> & { value?: TValue }\nexport type ResolvedLazyResult<TValue> = PromiseLike<TValue> & { value: TValue }\n\n/**\n * Calls the given function only when the returned promise-like object is\n * awaited. Afterwards, it provides the resolved value synchronously as `value`\n * property.\n */\nexport function createLazyResult<TValue>(\n  fn: () => Promise<TValue> | TValue\n): LazyResult<TValue> {\n  let pendingResult: Promise<TValue> | undefined\n\n  const result: LazyResult<TValue> = {\n    then(onfulfilled, onrejected) {\n      if (!pendingResult) {\n        pendingResult = Promise.resolve(fn())\n      }\n\n      pendingResult\n        .then((value) => {\n          result.value = value\n        })\n        .catch(() => {\n          // The externally awaited result will be rejected via `onrejected`. We\n          // don't need to handle it here. But we do want to avoid an unhandled\n          // rejection.\n        })\n\n      return pendingResult.then(onfulfilled, onrejected)\n    },\n  }\n\n  return result\n}\n\nexport function isResolvedLazyResult<TValue>(\n  result: LazyResult<TValue>\n): result is ResolvedLazyResult<TValue> {\n  return result.hasOwnProperty('value')\n}\n","// ISC License\n\n// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1\n\nconst { env, stdout } = globalThis?.process ?? {}\n\nconst enabled =\n  env &&\n  !env.NO_COLOR &&\n  (env.FORCE_COLOR || (stdout?.isTTY && !env.CI && env.TERM !== 'dumb'))\n\nconst replaceClose = (\n  str: string,\n  close: string,\n  replace: string,\n  index: number\n): string => {\n  const start = str.substring(0, index) + replace\n  const end = str.substring(index + close.length)\n  const nextIndex = end.indexOf(close)\n  return ~nextIndex\n    ? start + replaceClose(end, close, replace, nextIndex)\n    : start + end\n}\n\nconst formatter = (open: string, close: string, replace = open) => {\n  if (!enabled) return String\n  return (input: string) => {\n    const string = '' + input\n    const index = string.indexOf(close, open.length)\n    return ~index\n      ? open + replaceClose(string, close, replace, index) + close\n      : open + string + close\n  }\n}\n\nexport const reset = enabled ? (s: string) => `\\x1b[0m${s}\\x1b[0m` : String\nexport const bold = formatter('\\x1b[1m', '\\x1b[22m', '\\x1b[22m\\x1b[1m')\nexport const dim = formatter('\\x1b[2m', '\\x1b[22m', '\\x1b[22m\\x1b[2m')\nexport const italic = formatter('\\x1b[3m', '\\x1b[23m')\nexport const underline = formatter('\\x1b[4m', '\\x1b[24m')\nexport const inverse = formatter('\\x1b[7m', '\\x1b[27m')\nexport const hidden = formatter('\\x1b[8m', '\\x1b[28m')\nexport const strikethrough = formatter('\\x1b[9m', '\\x1b[29m')\nexport const black = formatter('\\x1b[30m', '\\x1b[39m')\nexport const red = formatter('\\x1b[31m', '\\x1b[39m')\nexport const green = formatter('\\x1b[32m', '\\x1b[39m')\nexport const yellow = formatter('\\x1b[33m', '\\x1b[39m')\nexport const blue = formatter('\\x1b[34m', '\\x1b[39m')\nexport const magenta = formatter('\\x1b[35m', '\\x1b[39m')\nexport const purple = formatter('\\x1b[38;2;173;127;168m', '\\x1b[39m')\nexport const cyan = formatter('\\x1b[36m', '\\x1b[39m')\nexport const white = formatter('\\x1b[37m', '\\x1b[39m')\nexport const gray = formatter('\\x1b[90m', '\\x1b[39m')\nexport const bgBlack = formatter('\\x1b[40m', '\\x1b[49m')\nexport const bgRed = formatter('\\x1b[41m', '\\x1b[49m')\nexport const bgGreen = formatter('\\x1b[42m', '\\x1b[49m')\nexport const bgYellow = formatter('\\x1b[43m', '\\x1b[49m')\nexport const bgBlue = formatter('\\x1b[44m', '\\x1b[49m')\nexport const bgMagenta = formatter('\\x1b[45m', '\\x1b[49m')\nexport const bgCyan = formatter('\\x1b[46m', '\\x1b[49m')\nexport const bgWhite = formatter('\\x1b[47m', '\\x1b[49m')\n","import { bold, green, magenta, red, yellow, white } from '../../lib/picocolors'\nimport { LRUCache } from '../../server/lib/lru-cache'\n\nexport const prefixes = {\n  wait: white(bold('')),\n  error: red(bold('')),\n  warn: yellow(bold('')),\n  ready: '', // no color\n  info: white(bold(' ')),\n  event: green(bold('')),\n  trace: magenta(bold('')),\n} as const\n\nconst LOGGING_METHOD = {\n  log: 'log',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nfunction prefixedLog(prefixType: keyof typeof prefixes, ...message: any[]) {\n  if ((message[0] === '' || message[0] === undefined) && message.length === 1) {\n    message.shift()\n  }\n\n  const consoleMethod: keyof typeof LOGGING_METHOD =\n    prefixType in LOGGING_METHOD\n      ? LOGGING_METHOD[prefixType as keyof typeof LOGGING_METHOD]\n      : 'log'\n\n  const prefix = prefixes[prefixType]\n  // If there's no message, don't print the prefix but a new line\n  if (message.length === 0) {\n    console[consoleMethod]('')\n  } else {\n    // Ensure if there's ANSI escape codes it's concatenated into one string.\n    // Chrome DevTool can only handle color if it's in one string.\n    if (message.length === 1 && typeof message[0] === 'string') {\n      console[consoleMethod](prefix + ' ' + message[0])\n    } else {\n      console[consoleMethod](prefix, ...message)\n    }\n  }\n}\n\nexport function bootstrap(message: string) {\n  console.log(message)\n}\n\nexport function wait(...message: any[]) {\n  prefixedLog('wait', ...message)\n}\n\nexport function error(...message: any[]) {\n  prefixedLog('error', ...message)\n}\n\nexport function warn(...message: any[]) {\n  prefixedLog('warn', ...message)\n}\n\nexport function ready(...message: any[]) {\n  prefixedLog('ready', ...message)\n}\n\nexport function info(...message: any[]) {\n  prefixedLog('info', ...message)\n}\n\nexport function event(...message: any[]) {\n  prefixedLog('event', ...message)\n}\n\nexport function trace(...message: any[]) {\n  prefixedLog('trace', ...message)\n}\n\nconst warnOnceCache = new LRUCache<string>(10_000, (value) => value.length)\nexport function warnOnce(...message: any[]) {\n  const key = message.join(' ')\n  if (!warnOnceCache.has(key)) {\n    warnOnceCache.set(key, key)\n    warn(...message)\n  }\n}\n\nconst errorOnceCache = new LRUCache<string>(10_000, (value) => value.length)\nexport function errorOnce(...message: any[]) {\n  const key = message.join(' ')\n  if (!errorOnceCache.has(key)) {\n    errorOnceCache.set(key, key)\n    error(...message)\n  }\n}\n","import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  renderToReadableStream,\n  decodeReply,\n  decodeReplyFromAsyncIterable,\n  createTemporaryReferenceSet as createServerTemporaryReferenceSet,\n} from 'react-server-dom-webpack/server'\nimport {\n  createFromReadableStream,\n  encodeReply,\n  createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n} from 'react-server-dom-webpack/client'\nimport { prerender } from 'react-server-dom-webpack/static'\n/* eslint-enable import/no-extraneous-dependencies */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernClient,\n  PrerenderStoreModernRuntime,\n  PrivateUseCacheStore,\n  RequestStore,\n  RevalidateStore,\n  UseCacheStore,\n  WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  getHmrRefreshHash,\n  getRenderResumeDataCache,\n  getPrerenderResumeDataCache,\n  workUnitAsyncStorage,\n  getDraftModeProviderForCacheScope,\n  getCacheSignal,\n  isHmrRefresh,\n  getServerComponentsHmrCache,\n  getRuntimeStagePromise,\n} from '../app-render/work-unit-async-storage.external'\n\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\n\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\n\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from '../app-render/manifests-singleton'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CacheSignal } from '../app-render/cache-signal'\nimport { decryptActionBoundArgs } from '../app-render/encryption'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { createReactServerErrorHandler } from '../app-render/create-error-handler'\nimport { DYNAMIC_EXPIRE, RUNTIME_PREFETCH_DYNAMIC_STALE } from './constants'\nimport { getCacheHandler } from './handlers'\nimport { UseCacheTimeoutError } from './use-cache-errors'\nimport {\n  createHangingInputAbortSignal,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n} from '../app-render/dynamic-rendering'\nimport {\n  makeErroringSearchParamsForUseCache,\n  type SearchParams,\n} from '../request/search-params'\nimport type { Params } from '../request/params'\nimport { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport type { CacheLife } from './cache-life'\nimport { RenderStage } from '../app-render/staged-rendering'\nimport * as Log from '../../build/output/log'\n\ninterface PrivateCacheContext {\n  readonly kind: 'private'\n  readonly outerWorkUnitStore:\n    | RequestStore\n    | PrivateUseCacheStore\n    | PrerenderStoreModernRuntime\n}\n\ninterface PublicCacheContext {\n  readonly kind: 'public'\n  // TODO: We should probably forbid nesting \"use cache\" inside unstable_cache.\n  readonly outerWorkUnitStore:\n    | Exclude<WorkUnitStore, PrerenderStoreModernClient>\n    | undefined\n}\n\ntype CacheContext = PrivateCacheContext | PublicCacheContext\n\ntype CacheKeyParts =\n  | [buildId: string, id: string, args: unknown[]]\n  | [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]\n\ninterface UseCachePageInnerProps {\n  params: Promise<Params>\n  searchParams?: Promise<SearchParams>\n}\n\nexport interface UseCachePageProps {\n  params: Promise<Params>\n  searchParams: Promise<SearchParams>\n  $$isPage: true\n}\n\nexport type UseCacheLayoutProps = {\n  params: Promise<Params>\n  $$isLayout: true\n} & {\n  // The value type should be React.ReactNode. But such an index signature would\n  // be incompatible with the other two props.\n  [slot: string]: any\n}\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? console.debug.bind(console, 'use-cache:')\n  : undefined\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\nfunction generateCacheEntry(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n  // generation cannot read anything from the context we're currently executing which\n  // might include request specific things like cookies() inside a React.cache().\n  // Note: It is important that we await at least once before this because it lets us\n  // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n  return workStore.runInCleanSnapshot(\n    generateCacheEntryWithRestoredWorkStore,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    timeoutError\n  )\n}\n\nfunction generateCacheEntryWithRestoredWorkStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  // Since we cleared the AsyncLocalStorage we need to restore the workStore.\n  // Note: We explicitly don't restore the RequestStore nor the PrerenderStore.\n  // We don't want any request specific information leaking an we don't want to create a\n  // bloated fake request mock for every cache call. So any feature that currently lives\n  // in RequestStore but should be available to Caches need to move to WorkStore.\n  // PrerenderStore is not needed inside the cache scope because the outer most one will\n  // be the one to report its result to the outer Prerender.\n  return workAsyncStorage.run(\n    workStore,\n    generateCacheEntryWithCacheContext,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    timeoutError\n  )\n}\n\nfunction createUseCacheStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  defaultCacheLife: Required<CacheLife>\n): UseCacheStore {\n  if (cacheContext.kind === 'private') {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    return {\n      type: 'private-cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash: getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: isHmrRefresh(workStore, outerWorkUnitStore),\n      serverComponentsHmrCache: getServerComponentsHmrCache(\n        workStore,\n        outerWorkUnitStore\n      ),\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      runtimeStagePromise: getRuntimeStagePromise(outerWorkUnitStore),\n      draftMode: getDraftModeProviderForCacheScope(\n        workStore,\n        outerWorkUnitStore\n      ),\n      rootParams: outerWorkUnitStore.rootParams,\n      headers: outerWorkUnitStore.headers,\n      cookies: outerWorkUnitStore.cookies,\n    }\n  } else {\n    let useCacheOrRequestStore: RequestStore | UseCacheStore | undefined\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    if (outerWorkUnitStore) {\n      switch (outerWorkUnitStore?.type) {\n        case 'cache':\n        case 'private-cache':\n        case 'request':\n          useCacheOrRequestStore = outerWorkUnitStore\n          break\n        case 'prerender-runtime':\n        case 'prerender':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'unstable-cache':\n          break\n        default:\n          outerWorkUnitStore satisfies never\n      }\n    }\n\n    return {\n      type: 'cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash:\n        outerWorkUnitStore && getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: useCacheOrRequestStore?.isHmrRefresh ?? false,\n      serverComponentsHmrCache:\n        useCacheOrRequestStore?.serverComponentsHmrCache,\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      draftMode:\n        outerWorkUnitStore &&\n        getDraftModeProviderForCacheScope(workStore, outerWorkUnitStore),\n    }\n  }\n}\n\nfunction assertDefaultCacheLife(\n  defaultCacheLife: CacheLife | undefined\n): asserts defaultCacheLife is Required<CacheLife> {\n  if (\n    !defaultCacheLife ||\n    defaultCacheLife.revalidate == null ||\n    defaultCacheLife.expire == null ||\n    defaultCacheLife.stale == null\n  ) {\n    throw new InvariantError(\n      'A default cacheLife profile must always be provided.'\n    )\n  }\n}\n\nfunction generateCacheEntryWithCacheContext(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  if (!workStore.cacheLifeProfiles) {\n    throw new InvariantError('cacheLifeProfiles should always be provided.')\n  }\n  const defaultCacheLife = workStore.cacheLifeProfiles['default']\n  assertDefaultCacheLife(defaultCacheLife)\n\n  // Initialize the Store for this Cache entry.\n  const cacheStore = createUseCacheStore(\n    workStore,\n    cacheContext,\n    defaultCacheLife\n  )\n\n  return workUnitAsyncStorage.run(cacheStore, () =>\n    dynamicAccessAsyncStorage.run(\n      { abortController: new AbortController() },\n      generateCacheEntryImpl,\n      workStore,\n      cacheContext,\n      cacheStore,\n      clientReferenceManifest,\n      encodedArguments,\n      fn,\n      timeoutError\n    )\n  )\n}\n\nfunction propagateCacheLifeAndTagsToRevalidateStore(\n  revalidateStore: RevalidateStore,\n  entry: CacheEntry\n): void {\n  const outerTags = (revalidateStore.tags ??= [])\n\n  for (const tag of entry.tags) {\n    if (!outerTags.includes(tag)) {\n      outerTags.push(tag)\n    }\n  }\n\n  if (revalidateStore.stale > entry.stale) {\n    revalidateStore.stale = entry.stale\n  }\n\n  if (revalidateStore.revalidate > entry.revalidate) {\n    revalidateStore.revalidate = entry.revalidate\n  }\n\n  if (revalidateStore.expire > entry.expire) {\n    revalidateStore.expire = entry.expire\n  }\n}\n\nfunction propagateCacheLifeAndTags(\n  cacheContext: CacheContext,\n  entry: CacheEntry\n): void {\n  if (cacheContext.kind === 'private') {\n    switch (cacheContext.outerWorkUnitStore.type) {\n      case 'prerender-runtime':\n      case 'private-cache':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  } else {\n    switch (cacheContext.outerWorkUnitStore?.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case 'unstable-cache':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  }\n}\n\nasync function collectResult(\n  savedStream: ReadableStream<Uint8Array>,\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  startTime: number,\n  errors: Array<unknown> // This is a live array that gets pushed into.\n): Promise<CacheEntry> {\n  // We create a buffered stream that collects all chunks until the end to\n  // ensure that RSC has finished rendering and therefore we have collected\n  // all tags. In the future the RSC API might allow for the equivalent of\n  // the allReady Promise that exists on SSR streams.\n  //\n  // If something errored or rejected anywhere in the render, we close\n  // the stream as errored. This lets a CacheHandler choose to save the\n  // partial result up until that point for future hits for a while to avoid\n  // unnecessary retries or not to retry. We use the end of the stream for\n  // this to avoid another complicated side-channel. A receiver has to consider\n  // that the stream might also error for other reasons anyway such as losing\n  // connection.\n\n  const buffer: Uint8Array[] = []\n  const reader = savedStream.getReader()\n\n  try {\n    for (let entry; !(entry = await reader.read()).done; ) {\n      buffer.push(entry.value)\n    }\n  } catch (error) {\n    errors.push(error)\n  }\n\n  let idx = 0\n  const bufferStream = new ReadableStream<Uint8Array>({\n    pull(controller) {\n      if (workStore.invalidDynamicUsageError) {\n        controller.error(workStore.invalidDynamicUsageError)\n      } else if (idx < buffer.length) {\n        controller.enqueue(buffer[idx++])\n      } else if (errors.length > 0) {\n        // TODO: Should we use AggregateError here?\n        controller.error(errors[0])\n      } else {\n        controller.close()\n      }\n    },\n  })\n\n  const collectedTags = innerCacheStore.tags\n  // If cacheLife() was used to set an explicit revalidate time we use that.\n  // Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested \"use cache\".\n  // If they're lower than our default.\n  const collectedRevalidate =\n    innerCacheStore.explicitRevalidate !== undefined\n      ? innerCacheStore.explicitRevalidate\n      : innerCacheStore.revalidate\n  const collectedExpire =\n    innerCacheStore.explicitExpire !== undefined\n      ? innerCacheStore.explicitExpire\n      : innerCacheStore.expire\n  const collectedStale =\n    innerCacheStore.explicitStale !== undefined\n      ? innerCacheStore.explicitStale\n      : innerCacheStore.stale\n\n  const entry: CacheEntry = {\n    value: bufferStream,\n    timestamp: startTime,\n    revalidate: collectedRevalidate,\n    expire: collectedExpire,\n    stale: collectedStale,\n    tags: collectedTags === null ? [] : collectedTags,\n  }\n\n  if (cacheContext.outerWorkUnitStore) {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    // Propagate cache life & tags to the parent context if appropriate.\n    switch (outerWorkUnitStore.type) {\n      case 'prerender':\n      case 'prerender-runtime': {\n        // If we've just created a cache result, and we're filling caches for a\n        // Cache Components prerender, then we don't want to propagate cache\n        // life & tags yet, in case the entry ends up being omitted from the\n        // final prerender due to short expire/stale times. If it is omitted,\n        // then it shouldn't have any effects on the prerender. We'll decide\n        // whether or not this cache should have its life & tags propagated when\n        // we read the entry in the final prerender from the resume data cache.\n\n        break\n      }\n      case 'request': {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          outerWorkUnitStore.cacheSignal\n        ) {\n          // If we're filling caches for a dev request, apply the same logic as prerenders do above,\n          // and don't propagate cache life/tags yet.\n          break\n        }\n        // fallthrough\n      }\n\n      case 'private-cache':\n      case 'cache':\n      case 'unstable-cache':\n      case 'prerender-legacy':\n      case 'prerender-ppr': {\n        propagateCacheLifeAndTags(cacheContext, entry)\n        break\n      }\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n\n    const cacheSignal = getCacheSignal(outerWorkUnitStore)\n    if (cacheSignal) {\n      cacheSignal.endRead()\n    }\n  }\n\n  return entry\n}\n\ntype GenerateCacheEntryResult =\n  | {\n      readonly type: 'cached'\n      readonly stream: ReadableStream\n      readonly pendingCacheEntry: Promise<CacheEntry>\n    }\n  | {\n      readonly type: 'prerender-dynamic'\n      readonly hangingPromise: Promise<never>\n    }\n\nasync function generateCacheEntryImpl(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n): Promise<GenerateCacheEntryResult> {\n  const temporaryReferences = createServerTemporaryReferenceSet()\n  const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n  const [, , args] =\n    typeof encodedArguments === 'string'\n      ? await decodeReply<CacheKeyParts>(\n          encodedArguments,\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n      : await decodeReplyFromAsyncIterable<CacheKeyParts>(\n          {\n            async *[Symbol.asyncIterator]() {\n              for (const entry of encodedArguments) {\n                yield entry\n              }\n\n              if (outerWorkUnitStore) {\n                switch (outerWorkUnitStore.type) {\n                  case 'prerender-runtime':\n                  case 'prerender':\n                    // The encoded arguments might contain hanging promises. In\n                    // this case we don't want to reject with \"Error: Connection\n                    // closed.\", so we intentionally keep the iterable alive.\n                    // This is similar to the halting trick that we do while\n                    // rendering.\n                    await new Promise<void>((resolve) => {\n                      if (outerWorkUnitStore.renderSignal.aborted) {\n                        resolve()\n                      } else {\n                        outerWorkUnitStore.renderSignal.addEventListener(\n                          'abort',\n                          () => resolve(),\n                          { once: true }\n                        )\n                      }\n                    })\n                    break\n                  case 'prerender-ppr':\n                  case 'prerender-legacy':\n                  case 'request':\n                  case 'cache':\n                  case 'private-cache':\n                  case 'unstable-cache':\n                    break\n                  default:\n                    outerWorkUnitStore satisfies never\n                }\n              }\n            },\n          },\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n\n  // Track the timestamp when we started computing the result.\n  const startTime = performance.timeOrigin + performance.now()\n\n  // Invoke the inner function to load a new result. We delay the invocation\n  // though, until React awaits the promise so that React's request store (ALS)\n  // is available when the function is invoked. This allows us, for example, to\n  // capture logs so that we can later replay them.\n  const resultPromise = createLazyResult(fn.bind(null, ...args))\n\n  let errors: Array<unknown> = []\n\n  // In the \"Cache\" environment, we only need to make sure that the error\n  // digests are handled correctly. Error formatting and reporting is not\n  // necessary here; the errors are encoded in the stream, and will be reported\n  // in the \"Server\" environment.\n  const handleError = createReactServerErrorHandler(\n    workStore.dev,\n    workStore.isBuildTimePrerendering ?? false,\n    workStore.reactServerErrorsByDigest,\n    (error) => {\n      // In production, we log the original error here. It gets a digest that\n      // can be used to associate the error with the obfuscated error that might\n      // be logged if the error is caught. In development, we prefer logging the\n      // transported error in the server environment. It's not obfuscated and\n      // also includes the (dev-only) environment name.\n      if (process.env.NODE_ENV === 'production') {\n        Log.error(error)\n      }\n\n      errors.push(error)\n    }\n  )\n\n  let stream: ReadableStream<Uint8Array>\n\n  switch (outerWorkUnitStore?.type) {\n    case 'prerender-runtime':\n    case 'prerender':\n      const timeoutAbortController = new AbortController()\n\n      // If we're prerendering, we give you 50 seconds to fill a cache entry.\n      // Otherwise we assume you stalled on hanging input and de-opt. This needs\n      // to be lower than just the general timeout of 60 seconds.\n      const timer = setTimeout(() => {\n        workStore.invalidDynamicUsageError = timeoutError\n        timeoutAbortController.abort(timeoutError)\n      }, 50000)\n\n      const dynamicAccessAbortSignal =\n        dynamicAccessAsyncStorage.getStore()?.abortController.signal\n\n      const abortSignal = dynamicAccessAbortSignal\n        ? AbortSignal.any([\n            dynamicAccessAbortSignal,\n            outerWorkUnitStore.renderSignal,\n            timeoutAbortController.signal,\n          ])\n        : timeoutAbortController.signal\n\n      const { prelude } = await prerender(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          signal: abortSignal,\n          temporaryReferences,\n          onError(error) {\n            if (abortSignal.aborted && abortSignal.reason === error) {\n              return undefined\n            }\n\n            return handleError(error)\n          },\n        }\n      )\n\n      clearTimeout(timer)\n\n      if (timeoutAbortController.signal.aborted) {\n        // When the timeout is reached we always error the stream. Even for\n        // fallback shell prerenders we don't want to return a hanging promise,\n        // which would allow the function to become a dynamic hole. Because that\n        // would mean that a non-empty shell could be generated which would be\n        // subject to revalidation, and we don't want to create long\n        // revalidation times.\n        stream = new ReadableStream({\n          start(controller) {\n            controller.error(timeoutAbortController.signal.reason)\n          },\n        })\n      } else if (dynamicAccessAbortSignal?.aborted) {\n        // If the prerender is aborted because of dynamic access (e.g. reading\n        // fallback params), we return a hanging promise. This essentially makes\n        // the \"use cache\" function dynamic.\n        const hangingPromise = makeHangingPromise<never>(\n          outerWorkUnitStore.renderSignal,\n          workStore.route,\n          'dynamic \"use cache\"'\n        )\n\n        if (outerWorkUnitStore.cacheSignal) {\n          outerWorkUnitStore.cacheSignal.endRead()\n        }\n\n        return { type: 'prerender-dynamic', hangingPromise }\n      } else {\n        stream = prelude\n      }\n      break\n    case 'request':\n      // If we're filling caches for a staged render, make sure that\n      // it takes at least a task, so we'll always notice a cache miss between stages.\n      //\n      // TODO(restart-on-cache-miss): This is suboptimal.\n      // Ideally we wouldn't need to restart for microtasky caches,\n      // but the current logic for omitting short-lived caches only works correctly\n      // if we do a second render, so that's the best we can do until we refactor that.\n      if (\n        process.env.NODE_ENV === 'development' &&\n        outerWorkUnitStore.cacheSignal\n      ) {\n        await new Promise((resolve) => setTimeout(resolve))\n      }\n    // fallthrough\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      stream = renderToReadableStream(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          temporaryReferences,\n          onError: handleError,\n        }\n      )\n      break\n    default:\n      return outerWorkUnitStore satisfies never\n  }\n\n  const [returnStream, savedStream] = stream.tee()\n\n  const pendingCacheEntry = collectResult(\n    savedStream,\n    workStore,\n    cacheContext,\n    innerCacheStore,\n    startTime,\n    errors\n  )\n\n  if (process.env.NODE_ENV === 'development') {\n    // Name the stream for React DevTools.\n    // @ts-expect-error\n    returnStream.name = 'use cache'\n  }\n\n  return {\n    type: 'cached',\n    // Return the stream as we're creating it. This means that if it ends up\n    // erroring we cannot return a stale-if-error version but it allows\n    // streaming back the result earlier.\n    stream: returnStream,\n    pendingCacheEntry,\n  }\n}\n\nfunction cloneCacheEntry(entry: CacheEntry): [CacheEntry, CacheEntry] {\n  const [streamA, streamB] = entry.value.tee()\n  entry.value = streamA\n  const clonedEntry: CacheEntry = {\n    value: streamB,\n    timestamp: entry.timestamp,\n    revalidate: entry.revalidate,\n    expire: entry.expire,\n    stale: entry.stale,\n    tags: entry.tags,\n  }\n  return [entry, clonedEntry]\n}\n\nasync function clonePendingCacheEntry(\n  pendingCacheEntry: Promise<CacheEntry>\n): Promise<[CacheEntry, CacheEntry]> {\n  const entry = await pendingCacheEntry\n  return cloneCacheEntry(entry)\n}\n\nasync function getNthCacheEntry(\n  split: Promise<[CacheEntry, CacheEntry]>,\n  i: number\n): Promise<CacheEntry> {\n  return (await split)[i]\n}\n\nasync function encodeFormData(formData: FormData): Promise<string> {\n  let result = ''\n  for (let [key, value] of formData) {\n    // We don't need this key to be serializable but from a security perspective it should not be\n    // possible to generate a string that looks the same from a different structure. To ensure this\n    // we need a delimeter between fields but just using a delimeter is not enough since a string\n    // might contain that delimeter. We use the length of each field as the delimeter to avoid\n    // escaping the values.\n    result += key.length.toString(16) + ':' + key\n    let stringValue\n    if (typeof value === 'string') {\n      stringValue = value\n    } else {\n      // The FormData might contain binary data that is not valid UTF-8 so this cache\n      // key may generate a UCS-2 string. Passing this to another service needs to be\n      // aware that the key might not be compatible.\n      const arrayBuffer = await value.arrayBuffer()\n      if (arrayBuffer.byteLength % 2 === 0) {\n        stringValue = String.fromCodePoint(...new Uint16Array(arrayBuffer))\n      } else {\n        stringValue =\n          String.fromCodePoint(\n            ...new Uint16Array(arrayBuffer, 0, (arrayBuffer.byteLength - 1) / 2)\n          ) +\n          String.fromCodePoint(\n            new Uint8Array(arrayBuffer, arrayBuffer.byteLength - 1, 1)[0]\n          )\n      }\n    }\n    result += stringValue.length.toString(16) + ':' + stringValue\n  }\n  return result\n}\n\nfunction createTrackedReadableStream(\n  stream: ReadableStream,\n  cacheSignal: CacheSignal\n) {\n  const reader = stream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await reader.read()\n      if (done) {\n        controller.close()\n        cacheSignal.endRead()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n\nexport async function cache(\n  kind: string,\n  id: string,\n  boundArgsLength: number,\n  originalFn: (...args: unknown[]) => Promise<unknown>,\n  argsObj: IArguments\n) {\n  let args = Array.prototype.slice.call(argsObj)\n\n  const isPrivate = kind === 'private'\n\n  // Private caches are currently only stored in the Resume Data Cache (RDC),\n  // and not in cache handlers.\n  const cacheHandler = isPrivate ? undefined : getCacheHandler(kind)\n\n  if (!isPrivate && !cacheHandler) {\n    throw new Error('Unknown cache handler: ' + kind)\n  }\n\n  const timeoutError = new UseCacheTimeoutError()\n  Error.captureStackTrace(timeoutError, cache)\n\n  const wrapAsInvalidDynamicUsageError = (\n    error: Error,\n    workStore: WorkStore\n  ) => {\n    Error.captureStackTrace(error, cache)\n    workStore.invalidDynamicUsageError ??= error\n\n    return error\n  }\n\n  const workStore = workAsyncStorage.getStore()\n  if (workStore === undefined) {\n    throw new Error(\n      '\"use cache\" cannot be used outside of App Router. Expected a WorkStore.'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  const name = originalFn.name\n  let fn = originalFn\n  let cacheContext: CacheContext\n\n  if (isPrivate) {\n    const expression = '\"use cache: private\"'\n\n    switch (workUnitStore?.type) {\n      // \"use cache: private\" is dynamic in prerendering contexts.\n      case 'prerender':\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        return throwToInterruptStaticGeneration(\n          expression,\n          workStore,\n          workUnitStore\n        )\n      case 'prerender-client':\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n        )\n      case 'unstable-cache': {\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} must not be used within \\`unstable_cache()\\`.`\n          ),\n          workStore\n        )\n      }\n      case 'cache': {\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} must not be used within \"use cache\". It can only be nested inside of another ${expression}.`\n          ),\n          workStore\n        )\n      }\n      case 'request':\n      case 'prerender-runtime':\n      case 'private-cache':\n        cacheContext = {\n          kind: 'private',\n          outerWorkUnitStore: workUnitStore,\n        }\n        break\n      case undefined:\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} cannot be used outside of a request context.`\n          ),\n          workStore\n        )\n      default:\n        workUnitStore satisfies never\n        // This is dead code, but without throwing an error here, TypeScript\n        // will assume that cacheContext is used before being assigned.\n        throw new InvariantError(`Unexpected work unit store.`)\n    }\n  } else {\n    switch (workUnitStore?.type) {\n      case 'prerender-client':\n        const expression = '\"use cache\"'\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n        )\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      // TODO: We should probably forbid nesting \"use cache\" inside\n      // unstable_cache. (fallthrough)\n      case 'unstable-cache':\n      case undefined:\n        cacheContext = {\n          kind: 'public',\n          outerWorkUnitStore: workUnitStore,\n        }\n        break\n      default:\n        workUnitStore satisfies never\n        // This is dead code, but without throwing an error here, TypeScript\n        // will assume that cacheContext is used before being assigned.\n        throw new InvariantError(`Unexpected work unit store.`)\n    }\n  }\n\n  // Get the clientReferenceManifest while we're still in the outer Context.\n  // In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.\n  const clientReferenceManifest = getClientReferenceManifest()\n\n  // Because the Action ID is not yet unique per implementation of that Action we can't\n  // safely reuse the results across builds yet. In the meantime we add the buildId to the\n  // arguments as a seed to ensure they're not reused. Remove this once Action IDs hash\n  // the implementation.\n  const buildId = workStore.buildId\n\n  // In dev mode, when the HMR refresh hash is set, we include it in the\n  // cache key. This ensures that cache entries are not reused when server\n  // components have been edited. This is a very coarse approach. But it's\n  // also only a temporary solution until Action IDs are unique per\n  // implementation. Remove this once Action IDs hash the implementation.\n  const hmrRefreshHash =\n    workUnitStore && getHmrRefreshHash(workStore, workUnitStore)\n\n  const hangingInputAbortSignal = workUnitStore\n    ? createHangingInputAbortSignal(workUnitStore)\n    : undefined\n\n  if (cacheContext.kind === 'private') {\n    const { outerWorkUnitStore } = cacheContext\n    switch (outerWorkUnitStore.type) {\n      case 'prerender-runtime': {\n        // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n        // are resolved with a delay, in the runtime stage. Private caches are one of these.\n        if (outerWorkUnitStore.runtimeStagePromise) {\n          await outerWorkUnitStore.runtimeStagePromise\n        }\n        break\n      }\n      case 'request': {\n        if (process.env.NODE_ENV === 'development') {\n          // Similar to runtime prerenders, private caches should not resolve in the static stage\n          // of a dev request, so we delay them.\n          await makeDevtoolsIOAwarePromise(\n            undefined,\n            outerWorkUnitStore,\n            RenderStage.Runtime\n          )\n        }\n        break\n      }\n      case 'private-cache':\n        break\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n  }\n\n  let isPageOrLayoutSegmentFunction = false\n\n  // For page and layout segment functions (i.e. the page/layout component,\n  // or generateMetadata/generateViewport), the cache function is\n  // overwritten, which allows us to apply special handling for params and\n  // searchParams. For pages and layouts we're using the outer params prop,\n  // and not the inner one that was serialized/deserialized. While it's not\n  // generally true for \"use cache\" args, in the case of `params` the inner\n  // and outer object are essentially equivalent, so this is safe to do\n  // (including fallback params that are hanging promises). It allows us to\n  // avoid waiting for the timeout, when prerendering a fallback shell of a\n  // cached page or layout that awaits params.\n  if (isPageSegmentFunction(args)) {\n    isPageOrLayoutSegmentFunction = true\n\n    const [\n      { params: outerParams, searchParams: outerSearchParams },\n      ...otherOuterArgs\n    ] = args\n\n    const props: UseCachePageInnerProps = {\n      params: outerParams,\n      // Omit searchParams and $$isPage.\n    }\n\n    if (isPrivate) {\n      // Private caches allow accessing search params. We need to include\n      // them in the serialized args and when generating the cache key.\n      props.searchParams = outerSearchParams\n    }\n\n    args = [props, ...otherOuterArgs]\n\n    fn = {\n      [name]: async (\n        {\n          params: _innerParams,\n          searchParams: innerSearchParams,\n        }: UseCachePageInnerProps,\n        ...otherInnerArgs: unknown[]\n      ) =>\n        originalFn.apply(null, [\n          {\n            params: outerParams,\n            searchParams:\n              innerSearchParams ??\n              // For public caches, search params are omitted from the cache\n              // key (and the serialized args) to avoid mismatches between\n              // prerendering and resuming a cached page that does not\n              // access search params. This is also the reason why we're not\n              // using a hanging promise for search params. For cached pages\n              // that do access them, which is an invalid dynamic usage, we\n              // need to ensure that an error is shown.\n              makeErroringSearchParamsForUseCache(workStore),\n          },\n          ...otherInnerArgs,\n        ]),\n    }[name] as (...args: unknown[]) => Promise<unknown>\n  } else if (isLayoutSegmentFunction(args)) {\n    isPageOrLayoutSegmentFunction = true\n\n    const [\n      { params: outerParams, $$isLayout, ...outerSlots },\n      ...otherOuterArgs\n    ] = args\n\n    // Overwrite the props to omit $$isLayout. Note that slots are only\n    // passed to the layout component (if any are defined), and not to\n    // generateMetadata nor generateViewport. For those functions,\n    // outerSlots/innerSlots is an empty object, which is fine because we're\n    // just spreading it into the props.\n    args = [{ params: outerParams, ...outerSlots }, ...otherOuterArgs]\n\n    fn = {\n      [name]: async (\n        {\n          params: _innerParams,\n          ...innerSlots\n        }: Omit<UseCacheLayoutProps, '$$isLayout'>,\n        ...otherInnerArgs: unknown[]\n      ) =>\n        originalFn.apply(null, [\n          { params: outerParams, ...innerSlots },\n          ...otherInnerArgs,\n        ]),\n    }[name] as (...args: unknown[]) => Promise<unknown>\n  }\n\n  if (boundArgsLength > 0) {\n    if (args.length === 0) {\n      throw new InvariantError(\n        `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive its encrypted bound arguments as the first argument.`\n      )\n    }\n\n    const encryptedBoundArgs = args.shift()\n    const boundArgs = await decryptActionBoundArgs(id, encryptedBoundArgs)\n\n    if (!Array.isArray(boundArgs)) {\n      throw new InvariantError(\n        `Expected the bound arguments of \"use cache\" function ${JSON.stringify(fn.name)} to deserialize into an array, got ${typeof boundArgs} instead.`\n      )\n    }\n\n    if (boundArgsLength !== boundArgs.length) {\n      throw new InvariantError(\n        `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive ${boundArgsLength} bound arguments, got ${boundArgs.length} instead.`\n      )\n    }\n\n    args.unshift(boundArgs)\n  }\n\n  const temporaryReferences = createClientTemporaryReferenceSet()\n\n  // For private caches, which are allowed to read cookies, we still don't\n  // need to include the cookies in the cache key. This is because we don't\n  // store the cache entries in a cache handler, but only in the Resume Data\n  // Cache (RDC). Private caches are only used during dynamic requests and\n  // runtime prefetches. For dynamic requests, the RDC is immutable, so it\n  // does not include any private caches. For runtime prefetches, the RDC is\n  // mutable, but only lives as long as the request, so the key does not\n  // need to include cookies.\n  const cacheKeyParts: CacheKeyParts = hmrRefreshHash\n    ? [buildId, id, args, hmrRefreshHash]\n    : [buildId, id, args]\n\n  const encodeCacheKeyParts = () =>\n    encodeReply(cacheKeyParts, {\n      temporaryReferences,\n      signal: hangingInputAbortSignal,\n    })\n\n  let encodedCacheKeyParts: FormData | string\n\n  switch (workUnitStore?.type) {\n    case 'prerender-runtime':\n    // We're currently only using `dynamicAccessAsyncStorage` for params,\n    // which are always available in a runtime prerender, so they will never hang,\n    // effectively making the tracking below a no-op.\n    // However, a runtime prerender shares a lot of the semantics with a static prerender,\n    // and might need to follow this codepath in the future\n    // if we start using `dynamicAccessAsyncStorage` for other APIs.\n    //\n    // fallthrough\n    case 'prerender':\n      if (!isPageOrLayoutSegmentFunction) {\n        // If the \"use cache\" function is not a page or layout segment\n        // function, we need to track dynamic access already when encoding\n        // the arguments. If params are passed explicitly into a \"use cache\"\n        // function (as opposed to receiving them automatically in a page or\n        // layout), we assume that the params are also accessed. This allows\n        // us to abort early, and treat the function as dynamic, instead of\n        // waiting for the timeout to be reached.\n        const dynamicAccessAbortController = new AbortController()\n\n        encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n          { abortController: dynamicAccessAbortController },\n          encodeCacheKeyParts\n        )\n\n        if (dynamicAccessAbortController.signal.aborted) {\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            workStore.route,\n            'dynamic \"use cache\"'\n          )\n        }\n        break\n      }\n    // fallthrough\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    // TODO(restart-on-cache-miss): We need to handle params/searchParams on page components.\n    // the promises will be tasky, so `encodeCacheKeyParts` will not resolve in the static stage.\n    // We have not started a cache read at this point, so we might just miss the cache completely.\n    // fallthrough\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      encodedCacheKeyParts = await encodeCacheKeyParts()\n      break\n    default:\n      return workUnitStore satisfies never\n  }\n\n  const serializedCacheKey =\n    typeof encodedCacheKeyParts === 'string'\n      ? // Fast path for the simple case for simple inputs. We let the CacheHandler\n        // Convert it to an ArrayBuffer if it wants to.\n        encodedCacheKeyParts\n      : await encodeFormData(encodedCacheKeyParts)\n\n  let stream: undefined | ReadableStream = undefined\n\n  // Get an immutable and mutable versions of the resume data cache.\n  const prerenderResumeDataCache = workUnitStore\n    ? getPrerenderResumeDataCache(workUnitStore)\n    : null\n  const renderResumeDataCache = workUnitStore\n    ? getRenderResumeDataCache(workUnitStore)\n    : null\n\n  if (renderResumeDataCache) {\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n    const cachedEntry = renderResumeDataCache.cache.get(serializedCacheKey)\n    if (cachedEntry !== undefined) {\n      const existingEntry = await cachedEntry\n      if (workUnitStore !== undefined && existingEntry !== undefined) {\n        if (\n          existingEntry.revalidate === 0 ||\n          existingEntry.expire < DYNAMIC_EXPIRE\n        ) {\n          switch (workUnitStore.type) {\n            case 'prerender':\n              // In a Dynamic I/O prerender, if the cache entry has\n              // revalidate: 0 or if the expire time is under 5 minutes,\n              // then we consider this cache entry dynamic as it's not worth\n              // generating static pages for such data. It's better to leave\n              // a dynamic hole that can be filled in during the resume with\n              // a potentially cached entry.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'prerender-runtime': {\n              // In the final phase of a runtime prerender, we have to make\n              // sure that APIs that would hang during a static prerender\n              // are resolved with a delay, in the runtime stage.\n              if (workUnitStore.runtimeStagePromise) {\n                await workUnitStore.runtimeStagePromise\n              }\n              break\n            }\n            case 'request': {\n              if (process.env.NODE_ENV === 'development') {\n                // We delay the cache here so that it doesn't resolve in the static task --\n                // in a regular static prerender, it'd be a hanging promise, and we need to reflect that,\n                // so it has to resolve later.\n                // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n                // and thus will cause a restart even if all caches are filled.\n                await makeDevtoolsIOAwarePromise(\n                  undefined,\n                  workUnitStore,\n                  RenderStage.Runtime\n                )\n              }\n              break\n            }\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (existingEntry.stale < RUNTIME_PREFETCH_DYNAMIC_STALE) {\n          switch (workUnitStore.type) {\n            case 'prerender-runtime':\n              // In a runtime prerender, if the cache entry will become\n              // stale in less then 30 seconds, we consider this cache entry\n              // dynamic as it's not worth prefetching. It's better to leave\n              // a dynamic hole that can be filled during the navigation.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'request': {\n              if (process.env.NODE_ENV === 'development') {\n                // We delay the cache here so that it doesn't resolve in the runtime phase --\n                // in a regular runtime prerender, it'd be a hanging promise, and we need to reflect that,\n                // so it has to resolve later.\n                // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                // We don't end the cache read here, so this will always appear as a cache miss in the runtime stage,\n                // and thus will cause a restart even if all caches are filled.\n                await makeDevtoolsIOAwarePromise(\n                  undefined,\n                  workUnitStore,\n                  RenderStage.Dynamic\n                )\n              }\n              break\n            }\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n      }\n\n      // We want to make sure we only propagate cache life & tags if the\n      // entry was *not* omitted from the prerender. So we only do this\n      // after the above early returns.\n      propagateCacheLifeAndTags(cacheContext, existingEntry)\n\n      const [streamA, streamB] = existingEntry.value.tee()\n      existingEntry.value = streamB\n\n      if (cacheSignal) {\n        // When we have a cacheSignal we need to block on reading the cache\n        // entry before ending the read.\n        stream = createTrackedReadableStream(streamA, cacheSignal)\n      } else {\n        stream = streamA\n      }\n    } else {\n      if (cacheSignal) {\n        cacheSignal.endRead()\n      }\n\n      if (workUnitStore) {\n        switch (workUnitStore.type) {\n          case 'prerender':\n            // If `allowEmptyStaticShell` is true, and thus a prefilled\n            // resume data cache was provided, then a cache miss means that\n            // params were part of the cache key. In this case, we can make\n            // this cache function a dynamic hole in the shell (or produce\n            // an empty shell if there's no parent suspense boundary).\n            // Currently, this also includes layouts and pages that don't\n            // read params, which will be improved when we implement\n            // NAR-136. Otherwise, we assume that if params are passed\n            // explicitly into a \"use cache\" function, that the params are\n            // also accessed. This allows us to abort early, and treat the\n            // function as dynamic, instead of waiting for the timeout to be\n            // reached. Compared to the instrumentation-based params bailout\n            // we do here, this also covers the case where params are\n            // transformed with an async function, before being passed into\n            // the \"use cache\" function, which escapes the instrumentation.\n            if (workUnitStore.allowEmptyStaticShell) {\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            }\n            break\n          case 'prerender-runtime':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n            break\n          default:\n            workUnitStore satisfies never\n        }\n      }\n    }\n  }\n\n  if (stream === undefined) {\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n    if (cacheSignal) {\n      // Either the cache handler or the generation can be using I/O at this point.\n      // We need to track when they start and when they complete.\n      cacheSignal.beginRead()\n    }\n\n    const lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind)\n\n    if (lazyRefreshTags && !isResolvedLazyResult(lazyRefreshTags)) {\n      await lazyRefreshTags\n    }\n\n    let entry: CacheEntry | undefined\n\n    // We ignore existing cache entries when force revalidating.\n    if (cacheHandler && !shouldForceRevalidate(workStore, workUnitStore)) {\n      entry = await cacheHandler.get(\n        serializedCacheKey,\n        workUnitStore?.implicitTags?.tags ?? []\n      )\n    }\n\n    if (entry) {\n      const implicitTags = workUnitStore?.implicitTags?.tags ?? []\n      let implicitTagsExpiration = 0\n\n      if (workUnitStore?.implicitTags) {\n        const lazyExpiration =\n          workUnitStore.implicitTags.expirationsByCacheKind.get(kind)\n\n        if (lazyExpiration) {\n          const expiration = isResolvedLazyResult(lazyExpiration)\n            ? lazyExpiration.value\n            : await lazyExpiration\n\n          // If a cache handler returns an expiration time of Infinity, it\n          // signals to Next.js that it handles checking cache entries for\n          // staleness based on the expiration of the implicit tags passed\n          // into the `get` method. In this case, we keep the default of 0,\n          // which means that the implicit tags are not considered expired.\n          if (expiration < Infinity) {\n            implicitTagsExpiration = expiration\n          }\n        }\n      }\n\n      if (\n        shouldDiscardCacheEntry(\n          entry,\n          workStore,\n          workUnitStore,\n          implicitTags,\n          implicitTagsExpiration\n        )\n      ) {\n        debug?.('discarding expired entry', serializedCacheKey)\n        entry = undefined\n      }\n    }\n\n    const currentTime = performance.timeOrigin + performance.now()\n    if (\n      workUnitStore !== undefined &&\n      entry !== undefined &&\n      (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n    ) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          // In a Dynamic I/O prerender, if the cache entry has revalidate:\n          // 0 or if the expire time is under 5 minutes, then we consider\n          // this cache entry dynamic as it's not worth generating static\n          // pages for such data. It's better to leave a dynamic hole that\n          // can be filled in during the resume with a potentially cached\n          // entry.\n          if (cacheSignal) {\n            cacheSignal.endRead()\n          }\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            workStore.route,\n            'dynamic \"use cache\"'\n          )\n        case 'request': {\n          if (process.env.NODE_ENV === 'development') {\n            // We delay the cache here so that it doesn't resolve in the static task --\n            // in a regular static prerender, it'd be a hanging promise, and we need to reflect that,\n            // so it has to resolve later.\n            // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n            // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n            // and thus will cause a restart even if all caches are filled.\n            await makeDevtoolsIOAwarePromise(\n              undefined,\n              workUnitStore,\n              RenderStage.Runtime\n            )\n          }\n          break\n        }\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (\n      entry === undefined ||\n      currentTime > entry.timestamp + entry.expire * 1000 ||\n      (workStore.isStaticGeneration &&\n        currentTime > entry.timestamp + entry.revalidate * 1000)\n    ) {\n      // Miss. Generate a new result.\n\n      // If the cache entry is stale and we're prerendering, we don't want to use the\n      // stale entry since it would unnecessarily need to shorten the lifetime of the\n      // prerender. We're not time constrained here so we can re-generated it now.\n\n      // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n      // generation cannot read anything from the context we're currently executing which\n      // might include request specific things like cookies() inside a React.cache().\n      // Note: It is important that we await at least once before this because it lets us\n      // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n\n      if (entry) {\n        if (currentTime > entry.timestamp + entry.expire * 1000) {\n          debug?.('entry is expired', serializedCacheKey)\n        }\n\n        if (\n          workStore.isStaticGeneration &&\n          currentTime > entry.timestamp + entry.revalidate * 1000\n        ) {\n          debug?.('static generation, entry is stale', serializedCacheKey)\n        }\n      }\n\n      const result = await generateCacheEntry(\n        workStore,\n        cacheContext,\n        clientReferenceManifest,\n        encodedCacheKeyParts,\n        fn,\n        timeoutError\n      )\n\n      if (result.type === 'prerender-dynamic') {\n        return result.hangingPromise\n      }\n\n      const { stream: newStream, pendingCacheEntry } = result\n\n      // When draft mode is enabled, we must not save the cache entry.\n      if (!workStore.isDraftMode) {\n        let savedCacheEntry\n\n        if (prerenderResumeDataCache) {\n          // Create a clone that goes into the cache scope memory cache.\n          const split = clonePendingCacheEntry(pendingCacheEntry)\n          savedCacheEntry = getNthCacheEntry(split, 0)\n          prerenderResumeDataCache.cache.set(\n            serializedCacheKey,\n            getNthCacheEntry(split, 1)\n          )\n        } else {\n          savedCacheEntry = pendingCacheEntry\n        }\n\n        if (cacheHandler) {\n          const promise = cacheHandler.set(serializedCacheKey, savedCacheEntry)\n\n          workStore.pendingRevalidateWrites ??= []\n          workStore.pendingRevalidateWrites.push(promise)\n        }\n      }\n\n      stream = newStream\n    } else {\n      // If we have an entry at this point, this can't be a private cache\n      // entry.\n      if (cacheContext.kind === 'private') {\n        throw new InvariantError(\n          `A private cache entry must not be retrieved from the cache handler.`\n        )\n      }\n\n      propagateCacheLifeAndTags(cacheContext, entry)\n\n      // We want to return this stream, even if it's stale.\n      stream = entry.value\n\n      // If we have a cache scope, we need to clone the entry and set it on\n      // the inner cache scope.\n      if (prerenderResumeDataCache) {\n        const [entryLeft, entryRight] = cloneCacheEntry(entry)\n        if (cacheSignal) {\n          stream = createTrackedReadableStream(entryLeft.value, cacheSignal)\n        } else {\n          stream = entryLeft.value\n        }\n\n        prerenderResumeDataCache.cache.set(\n          serializedCacheKey,\n          Promise.resolve(entryRight)\n        )\n      } else {\n        // If we're not regenerating we need to signal that we've finished\n        // putting the entry into the cache scope at this point. Otherwise we do\n        // that inside generateCacheEntry.\n        cacheSignal?.endRead()\n      }\n\n      if (currentTime > entry.timestamp + entry.revalidate * 1000) {\n        // If this is stale, and we're not in a prerender (i.e. this is\n        // dynamic render), then we should warm up the cache with a fresh\n        // revalidated entry.\n        const result = await generateCacheEntry(\n          workStore,\n          // This is not running within the context of this unit.\n          { kind: cacheContext.kind, outerWorkUnitStore: undefined },\n          clientReferenceManifest,\n          encodedCacheKeyParts,\n          fn,\n          timeoutError\n        )\n\n        if (result.type === 'cached') {\n          const { stream: ignoredStream, pendingCacheEntry } = result\n          let savedCacheEntry: Promise<CacheEntry>\n\n          if (prerenderResumeDataCache) {\n            const split = clonePendingCacheEntry(pendingCacheEntry)\n            savedCacheEntry = getNthCacheEntry(split, 0)\n            prerenderResumeDataCache.cache.set(\n              serializedCacheKey,\n              getNthCacheEntry(split, 1)\n            )\n          } else {\n            savedCacheEntry = pendingCacheEntry\n          }\n\n          if (cacheHandler) {\n            const promise = cacheHandler.set(\n              serializedCacheKey,\n              savedCacheEntry\n            )\n\n            workStore.pendingRevalidateWrites ??= []\n            workStore.pendingRevalidateWrites.push(promise)\n          }\n\n          await ignoredStream.cancel()\n        }\n      }\n    }\n  }\n\n  // Logs are replayed even if it's a hit - to ensure we see them on the client eventually.\n  // If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that\n  // never made it to the client. However, this also means that you see logs even when the\n  // cached function isn't actually re-executed. We should instead ensure prewarms always\n  // make it to the client. Another issue is that this will cause double logging in the\n  // server terminal. Once while generating the cache entry and once when replaying it on\n  // the server, which is required to pick it up for replaying again on the client.\n  const replayConsoleLogs = true\n\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: getServerModuleMap(),\n  }\n\n  return createFromReadableStream(stream, {\n    findSourceMapURL,\n    serverConsumerManifest,\n    temporaryReferences,\n    replayConsoleLogs,\n    environmentName: 'Cache',\n  })\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the page component itself,\n * or `generateMetadata`/`generateViewport` in a page file.\n */\nfunction isPageSegmentFunction(\n  args: any[]\n): args is [UseCachePageProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCachePageProps).$$isPage === true\n  )\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the layout component itself,\n * or `generateMetadata`/`generateViewport` in a layout file.\n */\nfunction isLayoutSegmentFunction(\n  args: any[]\n): args is [UseCacheLayoutProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCacheLayoutProps).$$isLayout === true\n  )\n}\n\nfunction shouldForceRevalidate(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined\n): boolean {\n  if (workStore.isOnDemandRevalidate || workStore.isDraftMode) {\n    return true\n  }\n\n  if (workStore.dev && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        return workUnitStore.headers.get('cache-control') === 'no-cache'\n      case 'cache':\n      case 'private-cache':\n        return workUnitStore.forceRevalidate\n      case 'prerender-runtime':\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nfunction shouldDiscardCacheEntry(\n  entry: CacheEntry,\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined,\n  implicitTags: string[],\n  implicitTagsExpiration: number\n): boolean {\n  // If the cache entry was created before any of the implicit tags were\n  // revalidated last, we need to discard it.\n  if (entry.timestamp <= implicitTagsExpiration) {\n    debug?.(\n      'entry was created at',\n      entry.timestamp,\n      'before implicit tags were revalidated at',\n      implicitTagsExpiration\n    )\n\n    return true\n  }\n\n  // During prerendering, we ignore recently revalidated tags. In dev mode, we\n  // can assume that the dynamic dev rendering will have discarded and recreated\n  // the affected cache entries, and we don't want to discard those again during\n  // the prerender validation. During build-time prerendering, there will never\n  // be any pending revalidated tags.\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n        return false\n      case 'prerender-runtime':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If the cache entry contains revalidated tags that the cache handler might\n  // not know about yet, we need to discard it.\n  if (entry.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  // Finally, if any of the implicit tags have been revalidated recently, we\n  // also need to discard the cache entry.\n  if (implicitTags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  return false\n}\n\nfunction isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {\n  const { previouslyRevalidatedTags, pendingRevalidatedTags } = workStore\n\n  // Was the tag previously revalidated (e.g. by a redirecting server action)?\n  if (previouslyRevalidatedTags.includes(tag)) {\n    debug?.('tag', tag, 'was previously revalidated')\n\n    return true\n  }\n\n  // It could also have been revalidated by the currently running server action.\n  // In this case the revalidation might not have been fully propagated by a\n  // remote cache handler yet, so we read it from the pending tags in the work\n  // store.\n  if (pendingRevalidatedTags?.some((item) => item.tag === tag)) {\n    debug?.('tag', tag, 'was just revalidated')\n\n    return true\n  }\n\n  return false\n}\n","export { cache } from '../../../../server/use-cache/use-cache-wrapper'\n"],"names":["getClientReferenceManifest","getServerActionsManifest","getServerModuleMap","selectWorkerForForwarding","setManifestsSingleton","MANIFESTS_SINGLETON","Symbol","for","globalThisWithManifests","globalThis","createProxiedClientReferenceManifest","clientReferenceManifestsPerRoute","createMappingProxy","prop","Proxy","get","_","id","workStore","workAsyncStorage","getStore","currentManifest","route","process","env","NODE_ENV","manifest","entry","undefined","values","mappingProxies","Map","InvariantError","proxy","set","String","createServerModuleMap","workers","NEXT_RUNTIME","workerEntry","normalizeWorkerPageName","page","Object","at","moduleId","async","name","chunks","pageName","pathHasPrefix","denormalizeWorkerPageName","bundlePath","normalizeAppPath","removePathPrefix","actionId","serverActionsManifest","keys","clientReferenceManifest","existingSingleton","proxiedClientReferenceManifest","serverModuleMap","getManifestsSingleton","manifestSingleton","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","stringToUint8Array","__next_loaded_action_key","buffer","bytes","Uint8Array","len","byteLength","fromCharCode","apply","binary","i","length","arr","charCodeAt","key","iv","data","crypto","subtle","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","importKey","atob","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","textEncoder","TextEncoder","textDecoder","TextDecoder","filterStackFrame","require","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","arg","Error","originalPayload","ivValue","slice","payload","decrypted","decode","startsWith","encodeActionBoundArg","randomBytes","workUnitAsyncStorage","exit","getRandomValues","encrypted","encode","btoa","ReadStatus","React","cache","args","workUnitStore","cacheSignal","getCacheSignal","clientModules","error","captureStackTrace","didCatchError","hangingInputAbortSignal","createHangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","addEventListener","once","serialized","streamToString","renderToReadableStream","signal","onError","err","aborted","message","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","encryptedPromise","decryptedBoundArgs","edgeRscModuleMapping","rscModuleMapping","deserialized","createFromReadableStream","ReadableStream","start","controller","enqueue","type","renderSignal","close","serverConsumerManifest","moduleLoading","moduleMap","formatServerError","getStackWithoutErrorMessage","invalidServerComponentReactHooks","setMessage","stack","lines","split","join","replace","includes","addedMessage","clientHook","regex","RegExp","test","HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","digest","prefix","httpStatus","has","Number","status","RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","errorCode","destination","statusCode","isNaN","isNextRouterError","getObjectClassLabel","isPlainObject","value","prototype","toString","call","getPrototypeOf","hasOwnProperty","isError","getProperError","safeStringifyLite","obj","seen","WeakSet","JSON","stringify","_key","add","createDigestWithErrorCode","extractNextErrorCode","ERROR_CODE_DELIMITER","thrownValue","originalDigest","__NEXT_ERROR_CODE","segments","find","segment","isReactLargeShellError","createHTMLErrorHandler","createReactServerErrorHandler","getDigestForWellKnownError","isUserLandError","isBailoutToCSRError","isDynamicServerError","isPrerenderInterruptedError","shouldFormatError","isNextExport","reactServerErrors","onReactServerRenderError","spanToRecordOn","stringHash","isAbortError","silenceLog","span","getTracer","getActiveScopeSpan","recordException","setAttribute","setStatus","code","SpanStatusCode","ERROR","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","componentStack","DYNAMIC_EXPIRE","RUNTIME_PREFETCH_DYNAMIC_STALE","LRUCache","LRUNode","constructor","size","prev","next","SentinelNode","maxSize","calculateSize","totalSize","head","tail","addToHead","node","removeNode","moveToHead","removeTail","lastNode","warn","existing","newNode","delete","iterator","current","remove","currentSize","createDefaultCacheHandler","Promise","resolve","refreshTags","getExpiration","updateTags","memoryCache","pendingSets","debug","NEXT_PRIVATE_DEBUG_CACHE","bind","pendingPromise","privateEntry","performance","timeOrigin","now","timestamp","revalidate","areTagsExpired","tags","areTagsStale","returnStream","newSaved","tee","expire","pendingEntry","resolvePending","clonedValue","reader","getReader","chunk","read","done","Buffer","from","isErrored","errorRetryCount","expirations","map","tag","tagsManifest","expired","expiration","Math","max","durations","round","existingEntry","updates","stale","getCacheHandler","getCacheHandlerEntries","getCacheHandlers","initializeCacheHandlers","setCacheHandler","log","handlersSymbol","handlersMapSymbol","handlersSetSymbol","reference","cacheMaxMemorySize","fallback","DefaultCache","RemoteCache","handler","kind","entries","cacheHandler","UseCacheTimeoutError","isUseCacheTimeoutError","USE_CACHE_TIMEOUT_ERROR_CODE","ReflectAdapter","target","receiver","Reflect","deleteProperty","createDedupedByCallsiteServerErrorLoggerDev","errorRef","fn","logErrorOrWarn","__NEXT_CACHE_COMPONENTS","flushCurrentErrorIfNew","getMessage","logDedupedError","callStackFrames","describeHasCheckingStringProperty","describeStringPropertyAccess","wellKnownProperties","isDefinitelyAValidIdentifier","stringifiedProp","isRequestAPICallableInsideAfter","throwForSearchParamsAccessInUseCache","throwWithStaticGenerationBailoutErrorWithDynamicError","expression","StaticGenBailoutError","constructorOpt","invalidDynamicUsageError","afterTaskStore","afterTaskAsyncStorage","rootTaskSpawnPhase","createPrerenderSearchParamsForClientPage","createSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","makeErroringSearchParamsForUseCache","underlyingSearchParams","createStaticPrerenderSearchParams","createRenderSearchParams","throwInvariantForMissingStore","createRuntimePrerenderSearchParams","forceStatic","makeHangingPromise","prerenderStore","makeHangingSearchParams","makeErroringSearchParams","delayUntilRuntimeStage","makeUntrackedSearchParams","requestStore","makeUntrackedSearchParamsWithDevWarnings","CachedSearchParams","WeakMap","CachedSearchParamsForUseCache","cachedSearchParams","promise","proxiedPromise","hasOwn","annotateDynamicAccess","dynamicShouldError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","asyncApiPromises","makeUntrackedSearchParamsWithDevWarningsImpl","promiseInitialized","proxiedUnderlying","instrumentSearchParamsObjectWithDevWarnings","sharedSearchParamsParent","reject","then","displayName","makeDevtoolsIOAwarePromise","RenderStage","Runtime","ignoreReject","instrumentSearchParamsPromiseWithDevWarnings","ownKeys","proxiedProperties","forEach","warnForSyncAccess","createSearchAccessError","createLazyResult","isResolvedLazyResult","pendingResult","result","onfulfilled","onrejected","catch","bgBlack","bgBlue","bgCyan","bgGreen","bgMagenta","bgRed","bgWhite","bgYellow","black","blue","bold","cyan","dim","gray","green","hidden","inverse","italic","magenta","purple","red","reset","strikethrough","underline","white","yellow","stdout","enabled","NO_COLOR","FORCE_COLOR","isTTY","CI","TERM","replaceClose","str","index","substring","end","nextIndex","indexOf","formatter","open","input","string","s","bootstrap","errorOnce","event","info","prefixes","ready","trace","wait","warnOnce","LOGGING_METHOD","prefixedLog","prefixType","shift","consoleMethod","warnOnceCache","errorOnceCache","generateCacheEntry","cacheContext","encodedArguments","timeoutError","runInCleanSnapshot","generateCacheEntryWithRestoredWorkStore","run","generateCacheEntryWithCacheContext","createUseCacheStore","defaultCacheLife","outerWorkUnitStore","phase","implicitTags","explicitRevalidate","explicitExpire","explicitStale","hmrRefreshHash","getHmrRefreshHash","isHmrRefresh","serverComponentsHmrCache","getServerComponentsHmrCache","forceRevalidate","shouldForceRevalidate","runtimeStagePromise","getRuntimeStagePromise","draftMode","getDraftModeProviderForCacheScope","rootParams","headers","cookies","useCacheOrRequestStore","assertDefaultCacheLife","cacheLifeProfiles","cacheStore","dynamicAccessAsyncStorage","abortController","AbortController","generateCacheEntryImpl","propagateCacheLifeAndTagsToRevalidateStore","revalidateStore","outerTags","propagateCacheLifeAndTags","collectResult","savedStream","innerCacheStore","startTime","errors","idx","bufferStream","pull","collectedTags","collectedRevalidate","collectedExpire","collectedStale","temporaryReferences","createServerTemporaryReferenceSet","decodeReply","decodeReplyFromAsyncIterable","asyncIterator","resultPromise","handleError","dev","isBuildTimePrerendering","reactServerErrorsByDigest","Log","stream","timeoutAbortController","timer","setTimeout","abort","dynamicAccessAbortSignal","abortSignal","AbortSignal","any","prelude","prerender","environmentName","reason","clearTimeout","hangingPromise","pendingCacheEntry","cloneCacheEntry","streamA","streamB","clonedEntry","clonePendingCacheEntry","getNthCacheEntry","encodeFormData","formData","stringValue","arrayBuffer","fromCodePoint","Uint16Array","createTrackedReadableStream","boundArgsLength","originalFn","argsObj","Array","isPrivate","wrapAsInvalidDynamicUsageError","buildId","isPageOrLayoutSegmentFunction","isPageSegmentFunction","params","outerParams","searchParams","outerSearchParams","otherOuterArgs","props","_innerParams","innerSearchParams","otherInnerArgs","isLayoutSegmentFunction","$$isLayout","outerSlots","innerSlots","boundArgs","isArray","unshift","createClientTemporaryReferenceSet","cacheKeyParts","encodeCacheKeyParts","encodeReply","encodedCacheKeyParts","dynamicAccessAbortController","serializedCacheKey","cachedEntry","Dynamic","allowEmptyStaticShell","lazyRefreshTags","refreshTagsByCacheKind","implicitTagsExpiration","lazyExpiration","expirationsByCacheKind","Infinity","shouldDiscardCacheEntry","currentTime","isStaticGeneration","newStream","isDraftMode","savedCacheEntry","pendingRevalidateWrites","entryLeft","entryRight","ignoredStream","cancel","replayConsoleLogs","maybeProps","$$isPage","isOnDemandRevalidate","some","isRecentlyRevalidatedTag","previouslyRevalidatedTags","pendingRevalidatedTags","item"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]}